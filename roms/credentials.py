# @fileName: credentials.py
# @creation_date: 18/09/2024
# @authors: averyark

""" Note: This description is generated by Copilot
This module provides functions to validate and set user credentials using an SQLite database.
"""
import sqlite3
from icecream import ic

from jwt.exceptions import InvalidTokenError
from passlib.context import CryptContext

# run "openssl rand -hex 32" in terminal to generate a new secret!
# NOTE: This secret is exposed and only intended for demonstrating purposes!
SECRET_KEY = "74faf15b3edd4a5d863ebc89d548cf5b19e5a84dd3817f7fb70dcefad009c208"
USE_ALGORITHM = "HS256"
JWT_EXPIRATION_MINUTES = 259200

credentialsPath = "mock-database.db"
db = sqlite3.connect(credentialsPath)
cursor = db.cursor()

pwd_context = CryptContext(schemes=["bcrypt"])

def validate_credentials(user_id: int, input: str):
    cursor.execute(
        f'''
            SELECT DISTINCT
                password
            FROM Credentials WHERE user_id IS '{user_id}'
        '''
    )

    row = cursor.fetchone()

    if not row:
        raise LookupError("User doesn't exist")

    if pwd_context.verify(input, row[0]):
        return True
    else:
        return False

def get_userid_from_email(email: str) -> int:
    user_id = None
    try:
        cursor.execute(
            f'''
                SELECT
                    user_id
                FROM Userdata WHERE email IS '{email}'
            '''
        )
        user_id = cursor.fetchone()[0]
    except Exception as err:
        pass

    return user_id

def set_credentials(email: str, password: str):
    hashed_password = pwd_context.hash(password)
    user_id = get_userid_from_email(email)
    if not user_id:
        raise LookupError("invalid email")

    cursor.execute(
        f'''
            INSERT INTO Credentials(
                id, user_id, password
            ) VALUES (
                NULL, '{user_id}', '{hashed_password}'
            )
        '''
    )
    db.commit()

# @fileName: login.py
# @creation_date: 19/09/2024
# @authors: averyark

""" Note: This description is generated by Copilot
This module provides functionality for user login and session management.
"""

from icecream import ic
import sqlite3
from datetime import datetime, timezone, timedelta

from .credentials import validate_credentials, SECRET_KEY, USE_ALGORITHM, JWT_EXPIRATION_MINUTES
from .user import get_user, User
from .api import app

from jwt import encode as jwt_encode, decode as jwt_decode, ExpiredSignatureError
from pydantic import BaseModel
from fastapi import HTTPException, status, Depends
from fastapi.security.oauth2 import OAuth2PasswordBearer, OAuth2PasswordRequestForm

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="account/swagger-login")

from typing import Annotated

credentialsPath = "mock-database.db"
db = sqlite3.connect(credentialsPath)
cursor = db.cursor()

# NOTE: Annotated[str, Depends(oauth2_scheme)] is for swagger interface
async def authenticate(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        # NOTE: Ignore _bcrypt.__about_ Error
        payload = jwt_decode(token, SECRET_KEY, algorithms=[USE_ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception

        # Check if the session token is still valid
        # Users can invalidate tokens by logging out (logout is not implemented as of 21 sep)
        cursor.execute(
            f'''
                SELECT user_id FROM UserSessionTokens
                WHERE token IS '{token}'
            '''
        )

        row = cursor.fetchone()

        if row is None:
            raise credentials_exception

        if row[0] != user_id:
            raise credentials_exception

    except ExpiredSignatureError:
        # Remove the session token from the database because it has expired
        cursor.execute(
            f'''
                DELETE FROM UserSessionTokens
                WHERE token IS {token}
            '''
        )
        db.commit()
        raise credentials_exception

    user = get_user(user_id)

    return user

class validate_role:
    def __init__(self, roles):
        self.roles = roles

    def __call__(self, user: Annotated[User, Depends(authenticate)]):
        if user.get_role() in self.roles:
            return True

        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Insufficient permissions"
        )

class Token(BaseModel):
    access_token: str
    token_type: str

@app.get(path="/account/login")
async def login(email: str, password: str) -> Token:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Incorrect email or password",
        headers={"WWW-Authenticate": "Bearer"},
    )
    # validate credentials
    # TODO: timing attack fix
    if email is None or password is None:
        raise credentials_exception

    user_id = get_userid_from_email(email)

    if user_id is None:
        raise credentials_exception

    if not validate_credentials(user_id, password):
        raise credentials_exception

    try:
        cursor.execute(
            f'''
                SELECT token FROM UserSessionTokens
                WHERE user_id IS {user_id}
            '''
        )
        row = cursor.fetchone()

        if not row is None:
            session_token = row[0]
        else:
            # NOTE: Ignore _bcrypt.__about_ Error
            session_token = jwt_encode({
                "sub": user_id,
                "exp": datetime.now(timezone.utc) + timedelta(minutes=JWT_EXPIRATION_MINUTES),
            }, SECRET_KEY , USE_ALGORITHM)

            cursor.execute(
                f'''
                    INSERT INTO UserSessionTokens(
                        user_id, token
                    ) VALUES (
                        {user_id},
                        '{session_token}'
                    )
                '''
            )
            db.commit()
    except Exception as err:
        session_token = None
        print(f"Unable to load userdata: {err}")

    if session_token is None:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error occurred"
        )

    ic(session_token)
    return Token(access_token=session_token, token_type="bearer")


# Login interface for swagger
@app.post(path="/account/swagger-login")
async def swagger_login(form: Annotated[OAuth2PasswordRequestForm, Depends()]) -> Token:
    # retrieve the user_id
    session_token = login(form.username, form.password)

    if not session_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Bearer"}
        )

    return Token(access_token=session_token, token_type="bearer")

def get_userid_from_email(email: str) -> int:
    user_id = None
    try:
        cursor.execute(
            f'''
                SELECT
                    user_id
                FROM Userdata WHERE email IS '{email}'
            '''
        )
        user_id = cursor.fetchone()[0]
    except Exception as err:
        pass

    return user_id

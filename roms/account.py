# @fileName: login.py
# @creation_date: 19/09/2024
# @authors: averyark

""" Note: This description is generated by Copilot
This module provides functionality for user login and session management.
"""

from icecream import ic
import sqlite3
from datetime import datetime, timezone, timedelta

from .credentials import validate_credentials, SECRET_KEY, USE_ALGORITHM, JWT_EXPIRATION_MINUTES, pwd_context
from .user import get_user, User
from .api import app

from jwt import encode as jwt_encode, decode as jwt_decode, ExpiredSignatureError
from pydantic import BaseModel
from fastapi import HTTPException, status, Depends
from fastapi.security.oauth2 import OAuth2PasswordBearer, OAuth2PasswordRequestForm

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="account/swagger-login")

from .user import User, validate_user_data
from .credentials import set_credentials
from typing import Annotated

credentialsPath = "mock-database.db"
db = sqlite3.connect(credentialsPath)
cursor = db.cursor()

# NOTE: Annotated[str, Depends(oauth2_scheme)] is for swagger interface
async def authenticate(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        # NOTE: Ignore _bcrypt.__about_ Error
        payload = jwt_decode(token, SECRET_KEY, algorithms=[USE_ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception

        # Check if the session token is still valid
        # Users can invalidate tokens by logging out (logout is not implemented as of 21 sep)
        cursor.execute(
            f'''
                SELECT user_id FROM UserSessionTokens
                WHERE token IS '{token}'
            '''
        )

        row = cursor.fetchone()

        if row is None:
            raise credentials_exception

        if row[0] != user_id:
            raise credentials_exception

    except ExpiredSignatureError:
        # Remove the session token from the database because it has expired
        cursor.execute(
            f'''
                DELETE FROM UserSessionTokens
                WHERE token IS {token}
            '''
        )
        db.commit()
        raise credentials_exception

    user = get_user(user_id)

    return user

class validate_role:
    def __init__(self, roles):
        self.roles = roles

    def __call__(self, user: Annotated[User, Depends(authenticate)]):
        if user.get_role() in self.roles:
            return True

        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Insufficient permissions"
        )

class UserInfo(BaseModel):
    birthday: str
    first_name: str
    last_name: str
    email: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

@app.get(path="/account/get_token", tags=["account"])
async def login(email: str, password: str) -> Token:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Incorrect email or password",
        headers={"WWW-Authenticate": "Bearer"},
    )
    # validate credentials
    # TODO: timing attack fix
    if email is None or password is None:
        raise credentials_exception

    user_id = get_userid_from_email(email)

    if user_id is None:
        raise credentials_exception

    if not validate_credentials(user_id, password):
        raise credentials_exception

    try:
        cursor.execute(
            f'''
                SELECT token FROM UserSessionTokens
                WHERE user_id IS {user_id}
            '''
        )
        row = cursor.fetchone()

        if not row is None:
            session_token = row[0]
        else:
            # NOTE: Ignore _bcrypt.__about_ Error
            session_token = jwt_encode({
                "sub": user_id,
                "exp": datetime.now(timezone.utc) + timedelta(minutes=JWT_EXPIRATION_MINUTES),
            }, SECRET_KEY , USE_ALGORITHM)

            cursor.execute(
                f'''
                    INSERT INTO UserSessionTokens(
                        user_id, token
                    ) VALUES (
                        {user_id},
                        '{session_token}'
                    )
                '''
            )
            db.commit()
    except Exception as err:
        session_token = None
        print(f"Unable to load userdata: {err}")

    if session_token is None:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error occurred"
        )

    ic(session_token)
    return Token(access_token=session_token, token_type="bearer")

@app.delete(path="/account/expire_token", tags=["account"])
async def logout(user: Annotated[User, Depends(authenticate)], token: str):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Unable to expire token",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        user = get_user(user.user_id)
    except:
        raise credentials_exception

    if not user.session_tokens.index(token):
        raise credentials_exception

    # commit after modifying
    user.session_tokens.remove(token)
    user.commit()

# Login interface for swagger
@app.post(path="/account/swagger_login", tags=["account"])
async def swagger_login(form: Annotated[OAuth2PasswordRequestForm, Depends()]) -> Token:
    # retrieve the user_id
    session_token = login(form.username, form.password)

    if not session_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Bearer"}
        )

    return Token(access_token=session_token, token_type="bearer")

def create_userdata(data: UserInfo, userPermission: int):
    cursor.execute(
        f'''
            INSERT INTO Userdata(
                user_id,
                email,
                first_name,
                last_name,
                birthday,
                permission_level
                ) VALUES (
                    NULL,
                    '{data.email}',
                    '{data.first_name}',
                    '{data.last_name}',
                    '{data.birthday}',
                    {userPermission or "10"}
                )
        '''
    )
    db.commit()

# NOTE: You cannot input permissionLevel from this api
@app.post(path="/account/signup", tags=["account"])
async def signup(data: UserInfo):
    try:
        validate_user_data(data)

        cursor.execute(
            f'''
                SELECT DISTINCT * FROM Userdata WHERE email IS '{data.email}'
            '''
        )
        row = cursor.fetchone()

        if row:
            raise LookupError("This email already exist in the database")

        try:
            create_userdata(data, 10)
            set_credentials(data.email, data.password)
        except Exception as err:
            raise err
    except LookupError as err:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=err
        )
    except Exception as err:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=err
        )

def get_userid_from_email(email: str) -> int:
    user_id = None
    try:
        cursor.execute(
            f'''
                SELECT
                    user_id
                FROM Userdata WHERE email IS '{email}'
            '''
        )
        user_id = cursor.fetchone()[0]
    except Exception as err:
        pass

    return user_id

# NOTE: This is used to create account with different permissionLevel, it is inaccessible at customer level. Requries authentication.
@app.post("/account/add/", tags=["account"])
def create_account(user: Annotated[User, Depends(validate_role(roles=["Manager"]))], data: UserInfo, permissionLevel):
    validate_user_data(data)

    cursor.execute(
        f'''
            SELECT DISTINCT * FROM Userdata WHERE email IS '{data.email}'
        '''
    )
    row = cursor.fetchone()

    if row:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Already exist")

    try:
        create_userdata(data, permissionLevel)
        set_credentials(data.email, data.password)
    except Exception as err:
        raise err

@app.patch("/account/edit/credentials/", tags=["account"])
def edit_credentials(
    user: Annotated[
        User, Depends(validate_role(roles=["Manager"]))
    ],
    user_id: int,
    new_credentials: str
):
    try:
        edited_user = get_user(user_id)
        edited_user.hashed_password = pwd_context.hash(new_credentials)
        edited_user.commit()
    except: raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)
